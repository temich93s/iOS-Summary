# View Controller Lifecycle

> [Источник информации](https://bestkora.com/IosDeveloper/lektsiya-9-cs193p-fall-2017-zhiznennyj-tsikl-view-controller-i-scroll-view/)

## Примечания:

- Первостепенное требование, которому вы **ДОЛЖНЫ** следовать в любом **iOS** приложении - **НИКОГДА НЕ БЛОКИРОВАТЬ** пользовательский интерфейс (**UI**). Способ, которым мы это добиваемся, заключается в том, что мы размещаем все, что могло бы блокировать наш **UI** (например, ожидание чего-то из сети), за пределами **main queue** (вне главного потока **main thread**), мы размещаем все это в фоновых (**background**) процессах.
- Всегда вызывайте **super** в ваших методах **“жизненного”** цикла.

## Жизненный цикл ViewController:

1. Получаем экземпляр класса **View Controller** (обычно со **storyboard**, но иногда вы можете запросить **View Controller** у **iOS**)
2. Затем вызывается **awakeFromNib** (только если получаем экземпляр класса со **storyboard**)
3. Далее происходит подготовка **“переезда”** (**segue**), если другие **MainVCs** готовят (**prepares**) ваш **View Controller**
4. Затем устанавливаются **outlets**, они **“подвязываются”** **iOS**. 
5. Затем вызывается **viewDidLoad**
6. Эти пары будут вызываться каждый раз, когда ваш **View Controller** будет **“приходить”**/**“уходить”** на/с экрана:
   - **viewWillAppear** и **viewDidAppear**
   - **viewWillDisappear** и **viewDidDisappear**
7. Эти методы “геометрия изменилась” вызываются в любое время после **viewDidLoad**. Между этими двумя вызовами срабатывает механизм **Autolayout**, поскольку **LayoutSubviews** запускает по умолчанию **Autolayout**:
   - **viewWillLayoutSubviews** и **viewDidLayoutSubviews** 
8. В любое время, если память будет заканчиваться, вы можете получить **didReceiveMemoryWarning**

## viewDidLoad (Основные первоначальные установки)

- **viewDidLoad** вызывается лишь один раз.
- Выполняйте основные первоначальные установки вашего **MainVC** здесь.
- Подходящее время для модификации **View**, с использованием **Модели**, например, потому что тут **Outlets** уже установлены.
- **Не делайте здесь никаких установок, связанных с “геометрией”! Ваши границы bounds еще не установлены!** Потому что вы ещё не знаете, на устройстве какого типа вы находитесь.	

```Swift
override func viewDidLoad() {
    super.viewDidLoad() 
}
```

## viewWillAppear (ПЕРЕД появлением на экране)

- Метод **viewWillAppear** вызывается, непосредственно **ПЕРЕД** появлением **View Controller** на экране. 
- И именно здесь вы можете **“наверстать”** те изменения в окружающем **Мире**, которые произошли пока ваш **View Controller** отсутствовал на экране, особенно, если **Модель** могла измениться как, например, в случае сетевой базы данных в качестве **Модели**. 
- Этот метод вызывается (многократно) всякий раз, когда **View Controller** возвращается на экран.
- Мы не запускаем тут ничего затратного по времени, так как заблокируется **UI** (не появится **View Controller** на экране)

```Swift
override func viewWillAppear(_ animated: Bool) {
    super.viewWillAppear(animated)
}
```

## viewDidAppear (ПОСЛЕ появления на экране)

- Метод **viewWillAppear** вызывается, сразу **ПОСЛЕ** появления **View Controller** на экране. 
- Поэтому это хорошее место для старта чего-нибудь затратного (например, выборки из сети, запуска анимации, наблюдение (**observing**) чего-то в **Мире**). Под **“затратностью”** мы обычно понимаем **“отнимающее много времени”**, но под этим можно также понимать батарею или память.
- Мы **НИКОГДА** не должны блокировать наш **UI** взаимодействия с пользователем (именно поэтому осуществляется фоновая выборка и т.д.). Наш **UI** может появиться на экране не полностью укомплектованным, из-за того что данные только подготавливаются, и наполниться позже, как только затратная операция будет закончена. Поэтому мы используем **“вращающееся колесико”**,  чтобы пользователь знал, что мы делаем некоторую затратную выборку. 

```Swift
override func viewDidAppear(_ animated: Bool) {
    super.viewDidAppear(animated)
}
```

## viewWillDisappear (ПЕРЕД уходом с экрана)

- Ваш **View Controller** всё ещё на экране, но через мгновение он покинет экран.
- Это прекрасное место для того, чтобы остановить все затратные операции запущенные во **viewDidAppear**, потому что сейчас вы знаете, что через мгновение **View Controller** исчезнет. Но когда вы вернетесь на экран, вы включите всё это снова в методе **viewDidAppear**.
- Два метода - **viewDidAppear** и **viewWillDisappear** - рассматриваются как зеркальное отображение друг друга. Это своего рода **DO** и **UNDO** некоторых действий, которые включаются и выключаются при появлении **View** на экране и при уходе его с экрана.

```Swift
override func viewWillDisappear(_ animated: Bool) {
super.viewWillDisappear(animated)
}
```

## viewDidDisappear (ПОСЛЕ ухода с экрана)

- Ваш **View Controller** ушел с экрана.
- Очень редко что-либо делается здесь, но изредка, вы могли бы тут сохранить некоторое состояние или освободить некоторый большой, но воссоздаваемый ресурс.

```Swift
override func viewDidDisappear(_ animated: Bool) {
    super.viewDidDisappear(animated)
}
```

## viewWillLayoutSubviews и viewDidLayoutSubviews (Геометрия) 

- **viewWillLayoutSubviews()** вызовается непосредственно **ПЕРЕД layoutSubviews**.
- **viewDidLayoutSubviews()** вызовается непосредственно **ПОСЛЕ layoutSubviews**.
- Эти два метода посылаются вашему **View Controller**, когда его собственному **self.view** посылается метод **layoutSubviews**. **layoutSubviews** - вызывается когда границы вашего топового **view** изменяются (или нуждаются в новом расположении).
- Почему этому **self.view** (топовому **view**) посылается сообщение **layoutSubviews**? По тем же самым причинам, что и другим **views**. Может быть, появились новые **subviews** или ушли какие-то ранее находившиеся там **subviews** из вашего **self.view** или изменились границы **bounds** вашего **self.view**. 
- **viewWillLayoutSubviews()** и **viewDidLayoutSubviews()** это самое подходящее место для осуществления установок **“связанных с геометрией”** (а **НЕ viewDidLoad**).
- Обычно нет необходимости что-то реализовывать эти методы. Потому что вы используете механизм **Autolayout**. И это автоматически осуществляется в методах **layoutSubviews** вашего топового **view**. Вот поэтому нет необходимости что-то подобное делать в вашем **Controller**. 
- Эти методы **viewWillLayoutSubviews()** и **viewDidLayoutSubviews()** могут вызываться очень часто. Так как система может вызывать методы **layoutSubviews** в любое время (так как системе разрешается размещать или проверять расположение **subviews** в любое время и в любом **view**, которое она сочтет приемлемым).
- Вы должны использовать эти методы надлежащим образом и обеспечить их эффективную работу.

```Swift
override func viewWillLayoutSubviews()
override func viewDidLayoutSubviews()
```

## viewWillTransition (Autorotation - автоматическое вращение устройства)

- **viewWillTransition** вызывается, когда ваше устройство переходит из ландшафтного режима в портретный и наоборот. 
- Когда устройство вращается вызывается **layoutSubviews**, потому что границы **bounds** вашего view меняются, соответственно будут вызваны методы **viewWillLayoutSubviews** и **viewDidLayoutSubviews**.
- **iOS** автоматически анимирует перемещение всех **subviews** из портретного **layoutSubviews** в ландшафтный **layoutSubviews**. 
- Можно вмешаться и внедрить свой код в анимацию вращения экрана. Координатор **coordinator**, который передается в этом методе, является анимационным координатором. У него есть метод с именем **animate(alongsideTransition:)**. Вы можете передать этому методу замыкание и выполнить с его помощью свою собственную анимацию. И эта анимация будет выполняться параллельно с анимацией, которую выполняет система при повороте устройства.


```Swift
override func viewWillTransition(
    to size: CGSize,
    with coordinator: UIViewControllerTrasitionCoordinator
)
```

## didReceiveMemoryWarning (Нехватка памяти)

- Если в вашем приложении есть **“утечка памяти”**, то вам будет выслано сообщение **didReceiveMemoryWarning**. (Это происходит редко, обычно означает создание очень больших видео, изображений или звуков)
- Этот метод просит ваш **View Controller** прекратить указывать на любые объекты, которые в данный момент не используются и занимают большую часть памяти, то есть их нужно удалить из **“кучи”** в данном методе. Например, вещи что не показываются на экране и не обрабатываются и которые я могу создать заново, если это необходимо (например, путем повторной выборки из интернета).
- Если ваше приложение имеет **“утечку памяти”** в **“куче”** и вы и никак не исправляете этот момент то тогда **iOS** может **“убить”** ваше приложение.

```Swift
override func didReceiveMemoryWarning() {
   super.didReceiveMemoryWarning() 
}
```

## awakeFromNib (“Пробуждение” со storyboard)

- **awakeFromNib** не является частью **“жизненного цикла” View Controller**.
- Любой объект, который приходит со **storyboard**, все ваши **UIView**, все ваши **ViewController** получают сообщение **awakeFromNib**. Сообщение **awakeFromNib** посылается **ViewController** **ОЧЕНЬ РАНО**, сразу после инициализации, но перед установкой **Outlets** и перед тем, как вы будете подготовлены как часть **“переезда”** (**segue**). 
- Во многом это место, которое следует использовать в последнюю очередь, в качестве крайней меры. Используйте сначала другие методы **“жизненного цикла”** **View Controller**, если это возможно. В основном это для ситуаций, когда код должен выполняться **ОЧЕНЬ РАНО** в **“жизненном цикле”**.

```Swift
override func awakeFromNib() (
   super.awakeFromNib() 
)
```
