# Работа c Realm

## 1. Установка Realm через CocoaPods

1. В терминале переходим в папку с проектом
```
cd /User/Desktop/Project
```
2. Инициализируем pod в проекте
```
pod init
```
3. Добавляем Realm в Podfile проекта
```
platform  :ios, '9.0' 
target  'Project' do
    use_frameworks!
    pod  'Realm-Swift' 
end
```
4. Загружаем и устанавливает pod в проекте

```
pod install
```

## 2. Импорт фреймворка для работы с Realm

- **RealmSwift** - это простая в использовании альтернатива SQLite и Core Data, которая делает сохранение, запрос и синхронизацию данных такими же простыми, как работа напрямую с собственными объектами Swift.

```Swift
// добавляем везде, где используем Realm
import RealmSwift
```

## 3. Первичная инициализация объекта, представляющего БД Realm в AppDelegate.swift

- **Realm()** - инициализация объекта, представляющего базу данных Realm.
- **Configuration** - экземпляр конфигурации описывает различные параметры, используемые для создания экземпляра Realm.
- **defaultConfiguration** - конфигурация по умолчанию, используемая для создания Realms, когда никакая конфигурация не указана явно (например, Realm())
- **fileURL** - локальный URL-адрес файла Realm.

### AppDelegate.swift
```Swift
@main
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        
        // Расположение БД в папке приложения
        print(Realm.Configuration.defaultConfiguration.fileURL)
        
        do {
            // Инициализируем БД Realm
            _ = try Realm()
        } catch {
            print(error.localizedDescription)
        }
        return true
    }
}
```

## 4. Создаем модель БД

OOP World|Realm World|Database World
:-----:|:----:|:----:
Class|Entity|Table
Property|Attribute|Field

- **Object** - это класс, используемый для определения объектов модели Realm. В Realm вы определяете свои классы моделей, создавая подклассы Object и добавляя свойства, которыми нужно управлять. Затем вы создаете экземпляры и используете свои пользовательские подклассы вместо прямого использования класса Object.
- **@objc dynamic** - это то, что называется модификатором объявления. Он в основном говорит среде выполнения использовать динамическую отправку, которая по стандарту изначально является статической отправкой. Это в основном позволяет отслеживать изменение свойства во время работы приложения. Это означает, что если пользователь во время работы приложения изменяет значение свойства name, то dynamic позволяет Realm динамически обновлять эти изменения в БД. Динамическая отправка - это то, что на самом деле происходит от API Objective-C. Таким образом, это означает, что мы должны отметить dynamic с помощью Objective-C, чтобы было ясно, что мы используем cреду выполнения Objective-C
- **List** - это тип контейнера в Realm, используемый для определения отношений ко-многим. Списки можно фильтровать и сортировать с помощью тех же предикатов, что и Results\<Element>. Свойства типа List, определенные в подклассах Object, должны быть объявлены как let и не могут быть динамическими.
- **LinkingObjects** - это автоматически обновляемый тип контейнера. Он представляет ноль или более объектов, которые связаны с принадлежащим ему объектом модели через отношения свойств.

### Category.swift
```Swift
// создаем первую сущность БД
class Category: Object {
    // создаем аттрибут и помечаем его dynamic для динамического обновления
    @objc dynamic var name: String = ""
    // создаем отношение Category к Item (один ко-многим)
    let items = List<Item>()
}
```

### Item.swift
```Swift
// создаем вторую сущность БД
class Item: Object {
    // создаем аттрибуты и помечаем его dynamic для динамического обновления
    @objc dynamic var title: String = ""
    @objc dynamic var done: Bool = false
    // создаем у Item связь с родительской сущностью Category
    let parentCategory = LinkingObjects(fromType: Category.self, property: "items")
}
```

## 5. Загрузка данных из БД

- **Results** — это автоматически обновляемый тип контейнера в Realm, возвращаемый из объектных запросов. Результаты можно запрашивать с помощью тех же предикатов, что и List<Element>, и вы можете связывать запросы для дальнейшей фильтрации результатов запроса.

```Swift
// Создаем экземпляр объекта модели Realm, что бы загрузить в него данные из БД Realm, а именно все экземпляры типа Item. Данные в categories обновляются автоматически, так как свойства в Item, помечены @objc dynamic
var categories: Results<Category>?
    
// создаем объект Realm для доступа к БД Realm
let realm = try! Realm()

// .objects - Возвращает все объекты указанного типа, хранящиеся в Realm.
categories = realm.objects(Category.self) 
```

## 6. Транзакция записи в БД

- **try realm.write({...})** - Выполняет действия, содержащиеся в данном блоке внутри транзакции записи. Для каждого файла Realm одновременно может быть открыта только одна транзакция записи. Транзакции записи не могут быть вложенными. Вызовы записи из экземпляров Realm для того же файла Realm в других потоках или других процессах будут блокироваться до тех пор, пока текущая транзакция записи не завершится или не будет отменена. Вы можете пропустить уведомление определенных блоков уведомлений об изменениях, внесенных в эту транзакцию записи, передав связанные с ними токены уведомлений. Это в первую очередь полезно, когда транзакция записи сохраняет изменения, уже внесенные в пользовательский интерфейс, и вы не хотите, чтобы блок уведомлений пытался повторно применить те же изменения.

```Swift
do {
    // Осуществляем изменения в БД в соотвествии с кодом указанным в замыкании
    try realm.write({
        // Тут указываем изменения, которые надо осуществить в БД
    })
} catch {
    print(error)
}

```

## 7. Добавление объекта в БД

- **realm.add(category)** - добавляет объект в Realm. Если объект с таким же первичным ключом уже существует в этой области, он обновляется значениями свойств из этого объекта. Добавление объекта в Realm также добавит все дочерние отношения, на которые ссылается этот объект. Этот метод может быть вызван только во время транзакции записи.

```Swift
do {
    // Осуществляем запись в БД в соотвествии с кодом указанным в замыкании
    try realm.write({
        // добавляет объект в Realm
        realm.add(category)
    })
} catch {
    print(error)
}

```

## 8. Удаление объекта из БД

- **realm.delete(item)** - удаляет объект из Realm. После удаления объекта он считается недействительным. Этот метод можно вызывать только во время транзакции записи.

```Swift
do {
    // Осуществляем запись в БД в соотвествии с кодом указанным в замыкании
    try realm.write({
        // Удаляет объект item из Realm
        realm.delete(item)
    })
} catch {
    print(error)
}

```

## 9. Фильтрация данных

- **filter** - возвращает результаты, содержащие все объекты, отфильтрованные по заданному предикату
- **sorted** - возвращает результаты, содержащие объекты в коллекции, но отсортированные. Объекты сортируются на основе значений заданного ключевого пути. ascending - по возрастанию

```Swift
// Фильтруем данные в БД оставляя только объекты у которых аттрибут "name" содержажат "text". И сортирует их по полю "name" в порядке возрастания
var filterCategory = categories?.filter("name CONTAINS[cd] %@", "text").sorted(byKeyPath: "name", ascending: true)
```

