# Наследование (Inheritance)

## 1. Общие сведения

- Класс может наследовать методы, свойства и другие характеристики другого класса. 
- Подкласс - это класс наследующий от другого класса.
- Суперкласс - это класс у которого наследуют.
- Классы в Swift могут вызывать или получать доступ к методам, свойствам, индексам, принадлежащим их суперклассам и могут предоставлять свои собственные переписанные версии этих методов, свойств, индексов для усовершенствования или изменения их поведения.
- Классы так же могут добавлять наблюдателей свойств к наследованным свойствам для того, чтобы быть в курсе, когда происходит смена значения свойства. Наблюдатели свойств могут быть добавлены для любого свойства, несмотря на то были ли они изначально определены как хранимые свойства или вычисляемые.

## 2. Определение базового класса

- Базовый класс - это класс который ничего не наследует из другого класса

```Swift
class Vehicle {
  var currentSpeed = 0.0
  var description: String {
    return "движется на скорости \(currentSpeed) миль в час"
  }
  func makeNoise() {
    //ничего не делаем, так как не каждый транспорт шумит
  }
}

let someVehicle = Vehicle()
print("Транспорт: \(someVehicle.description)")
//Транспорт: движется на скорости 0.0 миль в час
```

## 3. Наследование подклассом

- Наследование является актом создания нового класса на базе существующего класса (базового класса). 
- Подкласс наследует характеристики от существующего класса, который затем может быть усовершенствован. 
- Вы так же можете добавить новые характеристики подклассу.

```Swift
// Bicycle наследуется от Vehicle
class Bicycle: Vehicle {
  var hasBasket = false
}

let bicycle = Bicycle()
bicycle.hasBasket = true

bicycle.currentSpeed = 15.0
print("Велосипед: \(bicycle.description)")
//Велосипед: движется на скорости 15.0 миль в час
```

- Подклассы сами могут создавать подклассы.

```Swift
class Tandem: Bicycle {
  var currentNumberOfPassengers = 0
}

let tandem = Tandem()
tandem.hasBasket = true
tandem.currentNumberOfPassengers = 2
tandem.currentSpeed = 22.0
print("Тандем: \(tandem.description)")
// Тандем: движется на скорости 22.0 миль в час
```

## 4. Переопределение

- Переопределение (override) - это возможность подклассов проводить свои собственные реализации методов экземпляра, методов класса, свойств экземпляра, свойств класса или индекса, которые в противном случае будут наследоваться от суперкласса.

## 5. Доступ к методам, свойствам, индексам суперкласса

- Через префикс **super** - можно получить доступ к методу, свойству, индексу суперкласса

### Переопределение методов

- Вы можете переопределить унаследованный метод экземпляра или класса, чтобы обеспечить индивидуальную или альтернативную версию реализации метода в подклассе.

```Swift
class Train: Vehicle {
  override func makeNoise() {
    print("Чу-чу")
  }
}

let train = Train()
train.makeNoise()
// Выведет "Чу-чу"
```

### Переопределение свойств

- Вы можете переопределить унаследованные свойства класса или экземпляра для установки вашего собственного геттера и сеттера для этого свойства, или добавить наблюдателя свойства для наблюдения за переопределяемым свойством, когда меняется лежащее в основе значение свойства.

### Переопределение геттеров и сеттеров свойства

- Вы можете предусмотреть пользовательский геттер (и сеттер, если есть в этом необходимость) для переопределения любого унаследованного свойства, несмотря на то, как свойство было определено в самом источнике, как свойство хранения или как вычисляемое. 
- Подкласс не знает каким является унаследованное свойство хранимым или вычисляемым, все что он знает, так это имя свойства и его тип. 
- Вы всегда должны констатировать и имя, и тип свойства, которое вы переопределяете, для того чтобы компилятор мог проверить соответствие и наличие переопределяемого свойства у суперкласса.
- Вы можете представить унаследованное свойство только для чтения, как свойство, которое можно читать и редактировать, прописывая и геттер и сеттер в вашем переопределяемом свойстве подкласса. 
- Вы не можете сделать редактируемое и читаемое свойство только свойством для чтения.
- Если вы предоставляете сеттер как часть переопределения свойства, то вы должны предоставить и геттер для этого переопределения. Если вы не хотите изменять значение наследуемого свойства внутри переопределяемого геттера, то вы можете просто передать через наследуемое значение, возвращая super.someProperty от геттера, где someProperty - имя параметра, который вы переопределяете.

```Swift
class Car: Vehicle {
  var gear = 1
  override var description: String {
    return super.description + " на передаче \(gear)"
  }
}

let car = Car()
car.currentSpeed = 25.0
car.gear = 3
print("Машина: \(car.description)")
// Выведет "Машина: движется на скорости 25.0 миль в час на передаче 3"
```

### Переопределение геттеров и сеттеров свойства

- Вы можете использовать переопределение свойства для добавления наблюдателей к унаследованному свойству. Это позволяет вам получать уведомления об изменении значения унаследованного свойства, несмотря на то, как изначально это свойство было реализовано.
- Вы не можете добавить наблюдателей свойства на унаследованное константное свойство или на унаследованные вычисляемые свойства только для чтения.

```Swift
class AutomaticCar: Car {
  override var currentSpeed: Double {
    didSet {
      gear = Int(currentSpeed / 10.0) + 1
    }
  }
}

let automatic = AutomaticCar()
automatic.currentSpeed = 35.0
print("Машина с автоматом: \(automatic.description)")
//Выведет "Машина с автоматом: движется на скорости 35.0 миль в час на передаче 4"
```

## 6. Предотвращение переопределений

- Вы можете предотвратить переопределение метода, свойства или индекса, обозначив его как конечный. Сделать это можно написав ключевое слово **final** перед ключевым словом метода, свойства или индекса (final var, final func, final class func, и final subscript).
- Вы можете отметить целый класс как конечный или финальный, написав слово final перед ключевым словом class (final class). Любая попытка унаследовать класс также приведет к ошибке компиляции.
