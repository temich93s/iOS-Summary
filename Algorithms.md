# Алгоритмы

## :red_square: Общее

### Общее

- **Алгоритм** - набор инструкций для выполнения некоторой задачи.
- **Псевдокод** – представляет собой высокоуровневое описание решаемой задачи. Он записывается в форме, похожей на программный код, но в большей степени напоминает естественный язык.
- **Стек вызовов** - когда вы вызываете функцию из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии. Все значения переменных этой функции остаются в памяти. 
  - Каждый вызов создает собственную копию переменной х. Обратиться к переменной х, принадлежащей другой функции, невозможно.
  - Если стек вызовов станет очень большим, oн займет слишком много памяти.
- **Виды доступа** - всего существуют два вида доступа: произвольный (у массивов) и последовательный (у связанных списков).
  - Связанные списки - хорошо подходят для вставки/удаления. Так как надо поменять всего 1 указатель у предыдущего элемента, а у массива надо сдвигать все элементы.
  - Массивы - хорошо подходят для произвольного доступа к элементам.

### О-большое

- Всегда должны выбирать самый эффективный алгоритм по времени и/или по памяти.
- О-большое описывает скорость работы алгоритма.
- О-большое определяет время выполнения в худшем случае
- Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций. 
- Формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.
-  В «О-большом» константы игнорируются и игнорируются числа, задействованные в операциях сложения, вычитания, умножения или деления. Ни одно из следующих значений не является правильной записью «О-большое»: О(n + 26), О(n - 26), О(n * 26), О(n / 26). Все они эквивалентны 0(n)
- Время 0(1) называется постоянным. 

### Рекурсия

- Рекурсией называется вызов функцией самой себя. 
- Каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая. 
  - В рекурсивном случае функция вызывает сама себя. 
  - В базовом случае функция себя не вызывает, чтобы предотвратить зацикливание.
- Когда вы пишете рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента.
- В языках функционального программирования циклов нет, поэтому для написания подобных функций приходится применять рекурсию. 

### Метод доказательства по индукции. 

- Каждое индуктивное доказательство состоит из двух частей: базы (базового случая) и индукционного перехода.
- Работоспособность алгоритма быстрой сортировки: 
  - базовый случай — массивов с размером 0 и 1 — их сортировать не нужно. 
  - индукционный переход - если быстрая сортировка работает для массива из 1 элемента, то она будет работать для массива из 2 элементов. А если она работает для массивов из 2 элементов, то она будет работать для массивов из 3 элементов и т. д.

### Разделяй и властвуй

- Решение задачи методом «разделяй и властвуй» состоит из двух шагов:
  1.  Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных.
  2.  Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.

### Хеш-функция

- Хеш-функция, или функция свёртки — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. 
- Хеш-функция должна соответствовать следующим требованиям:
  - Она должна быть последовательной. Передавая одно и то же значение получаем один и тот же результат.
  - Разным переданным значениям должны соответствовать разные результаты. 

### NP-полные задачи 

## :red_square: Структуры данных

### Массивы
- Массив – хранит все элементы в памяти рядом, если что-то надо добавить, и соседняя память занята, то ищется новое свободное место в памяти для всего массива с новым элементом.
- Работая с массивом, вы заранее знаете адрес каждого его элемента. 
- Все массивы начинаются с 0
- Позиция элемента в массиве называется его индексом.
- Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).

```Swift
func {}
```

### Связанные списки
- При использовании связанного списка элементы могут размещаться где угодно в памяти.
- В каждом элементе хранится адрес следующего элемента списка. Таким образом, набор - произвольных адресов памяти объединяется в цепочку.
- Обратиться к конкретному элементу списка напрямую нельзя. Мы не знаем заранее адрес каждого элемента. Данные у списков считываются последовательно.


### Стек

- Стек – абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO («последним пришёл — первым вышел»).
- Стек поддерживает всего два действия: занесение (вставка) и извлечение (выведение из списка и чтение)

```Swift
func {}
```

### Очереди

- Вы не можете обращаться к произвольным элементам очереди (как и у стека)
- Поддерживают всего две операции: постановка в очередь и извлечение из очереди
- Очередь относится к категории структур данных FIFO: First In, First Out («первым вошел, первым вышел»).

### Хеш-таблица

- Хеш-таблицы (словари) – связанные воедино хеш-функция и массив. Они определяют место хранения элементов при помощи хеш-функций.
- Хеш-таблица состоит из ключей и значений.
- В среднем хеш-таблицы выполняют любые операции за время 0(1).
- Хеш-таблицы хорошо подходят для решения следующих задач:
  - моделирование отношений между объектами;
  - устранение дубликатов;
  - кэширование/запоминание данных вместо выполнения работы на сервере.

#### Коллизии

- Коллизии - двум ключам назначается один элемент массива
- Существует много разных стратегий обработки коллизий. Простейшая из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.
- Из этого примера следуют два важных урока:
  - хеш-функция должна распределять ключи равномерно по всему хешу;
  - если связанные списки становятся слишком длинными, работа с хеш-таблицей сильно замедляется.
- Для предотвращения коллизий необходимо:
  - низкий коэффициент заполнения;
  - хорошая хеш-функция.

#### Коэффициент заполнения

- Коэффициент заполнения = кол-во эл-тов в хеш-таблице / общее кол-во эл-тов
- С меньшим коэффициентом заполнения число коллизий уменьшается, и ваша таблица начинает работать более эффективно. 
- Хорошее приближенное правило: изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7. 
  - Хорошая Хэш-функция должная обеспечивать равномерное распределение значений в массиве.
  - Плохая хеш-функция создает скопления и порождает множество коллизий.

### Графы

- Каждый граф состоит из узлов и ребер.
- Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называются соседями.
- Граф можно реализовать через хеш-таблицу
- В ненаправленном графе стрелок нет, и каждый из узлов является соседом по отношению друг к другу.
- Вес – число связанное с ребром графа
- Граф с весами называется взвешенным графом. Граф без весов называется невзвешенным графом.
- Для вычисления кратчайшего пути в невзвешенном графе используется поиск в ширину. 
- Кратчайшие пути во взвешенном графе вычисляются по алгоритму Дейкстры.
- В графах также могут присутствовать циклы: Само понятие ненаправленного графа означает, что каждый из двух узлов фактически ведет к другому узлу

## :red_square: Задачи

### Задача о коммивояжере (Разделяй и властвуй)

- ЗАДАЧА: 
  - Коммивояжер хочет побывать в каждом из городов так, чтобы при этом проехать минимальное общее расстояние. 
- РЕШЕНИЕ: 
  - Одно из возможных решений: нужно перебрать все возможные комбинации порядка объезда городов. Время выполнения составит 0(n!). Это одна из знаменитых нерешенных задач в области теории вычислений. Для нее не существует известного быстрого алгоритма, и ученые считают, что найти более эффективный алгоритм для этой задачи в принципе невозможно.

### Задача про деление земли на равные квадраты

- ЗАДАЧА: 
  - Нужно разбить участок земли на равные квадраты.
- РЕШЕНИЕ ():
  - Разбиваем участок земли на максимально большие квадраты. Оставшийся участок земли разбиваем заново на новые максимально возможные квадраты и т.д. повторяем пока оставшиеся участок не разобьется на квадраты поровну. Как разобьется минимальный квадрат и есть тот кваддрат на который можно разбить участок

### Задача про манго

- ЗАДАЧА: 
  - Есть манго надо найти ближайшего покупателя манго.
- РЕШЕНИЕ (Поиск в ширину): 
  1. создаем очередь из ближайших друзей
  2. проверяем друга из очереди (первого в очереди, по правилу очереди) готов ли он купить манго, если нет, то добавляем ближайших друзей этого проверенного друга в очередь (они добавляются в конец, по правилу очереди)
  3. повторяем. Проверяем следующего друга в очереди

### Задача про обмен

- ЗАДАЧА: 
  - Максимально выгодно обменять предметы, где есть доплата при обмене. 
- РЕШЕНИЕ: Алгоритм Дейкстры
  - Узлы графа — это предметы, на которые может поменяться Рама. Веса ребер представляют сумму доплаты за обмен. 
  - Для реализации этого примера понадобятся три хеш-таблицы (граф, стоимости, родители).
  - Хеш-таблицы стоимостей и родителей будут обновляться по ходу работы алгоритма.
  - Стоимость узла определяет, сколько времени потребуется для перехода к этому узлу от начального узла.
  - так же нужен массив для отслеживания всех уже обработанных узлов, так как один узел не должен обрабатываться многократно.
  - Алгоритм:
    - Пока остаются необработанные узлы: 
    - взять узел ближайший к началу, 
    - обновить стоимости для его соседей
    - если стоимости каких-либо соседей были обновлены, обновить и родителей
    - пометит узел как обработанный и вернуться к началу алгоритма

### Задача про воришку и рюкзак

- ЗАДАЧА: 
  - Нужно положить в рюкзак ограниченного веса максимально дорогие вещи
- РЕШЕНИЕ: Динамическое программирование
  - составляем таблицу, где строка это предметы, а столбцы это от 0 до веса рюкзака, где кратность это вес минимального предмета
  - на каждом шаге заполняем таблицу, указывая можно ли добавить текущий предмет в рюкзак, или заменить предмет, если текущий предмет больше стоит текущей сумарной стоимости

### Задача про апельсины и грейпфруты

- ЗАДАЧА: 
  - Нужно определить по признакам фрукт относится к апельсинам или к грейпфруту
- РЕШЕНИЕ: Алгоритм к ближайших соседей
  - Размер и цвет - признаки, по которым ведется сравнение.
  - Для вычисления расстояния между двумя точками применяется формула Пифагора, где () это признак

## :red_square: Поиск

### Простой поиск

- Простой поиск - при каждой догадке исключается только одно число. Например, последовательное угадываение чисел.

```Swift
func {}
```

### Бинарный поиск

- Бинарный поиск — на каждом шаге множество объектов делится на две части и в работе остаётся та часть множества, где находится искомый объект. 
- Бинарный поиск работает только с отсортированным списком элементов.

```Swift
func {}
```

### Поиск в ширину

- Поиск в ширину позволяет найти минимальное кол-во узлов между двумя объектами.
- Поиск в ширину работает с графами. Он помогает ответить на вопросы двух типов:
  - тип 1: существует ли путь от узла А к узлу В?
  - тип 2: как выглядит кратчайший путь от узла А к узлу В?
- Чтобы найти кратчайший путь, нужно выполнить два шага:
  1. Смоделировать задачу в виде графа.
  2. Решить задачу методом поиска в ширину.
- Поиск в ширину выполняется за время О(количество узлов + количество ребер), что обычно записывается в форме О(V+E) (У — количество узлов, Е — количество ребер). 

```Swift
func {}
```

### Алгоритм дейкстры

- Алгоритм Дейкстры используется для поиска пути от начальной точки к конечной за кратчайшее возможное время.
- Алгоритм Дейкстры состоит из четырех шагов:
  1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
  2. Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости.
  3. Повторять, пока это не будет сделано для всех узлов графа.
  4. Вычислить итоговый путь.
- Алгоритм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).
- Алгоритм Дейкстры не может использоваться при наличии ребер, имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый алгоритмом Беллмапа- Форда.

```Swift
func {}
```

### Алгоритм динамическое программирование

- Алгоритм динамического программирования начинается с решения подзадач с постепенным переходом к решению полной задачи.
- Каждый алгоритм динамического программирования начинается с таблицы. 
- При каждой итерации сохраняется текущая оценка максимума.
- Алгоритм динамического программированияне предусматривает возможность взять половину предмета.
- Динамическое программирование работает только в том случае, если каждая подзадача автономна, то есть не зависит от других подзадач.
- Динамическое программирование применяется для оптимизации какой-либо характеристики при заданных ограничениях.
- В каждом решении из области динамического программирования строится таблица;
- Значения ячеек таблицы обычно соответствуют оптимизируемой характеристике.
- Каждая ячейка представляет подзадачу, поэтому вы должны подумать о том, как разбить задачу на подзадачи. Это поможет вам определиться с осями.
- Не существует единой формулы для вычисления решений методом динамического программирования.

### Алгоритм к ближайших соседей

- У алгоритма k ближайших соседей есть два основных применения: классификация и регрессия:
  - классификация - распределение по категориям;
  - регресия - прогнозирование ответа (в числовом выражении).
- Классификация: Для вычисления расстояния между двумя точками применяется формула Пифагора.
- Классификация: На практике также часто применяется метрика близости косинусов. Метрика близости косинусов не измеряет расстояние между двумя векторами. Вместо этого она сравнивает углы двух векторов и в целом лучше подходит для подобных случаев.
- Регресия: беруться ближайшие соседи и берется их среднее значение по предполагаемой оценке
- "Извлечением признаков" называется преобразование элемента (например, фрукта или пользователя) в список чисел, которые могут использоваться для сравнения.
- Качественный выбор признаков — важная часть успешного алгоритма k ближайших соседей. Под правильным выбором признаков следует понимать:
  - признаки, напрямую связанны с тем что мы пытаемся определить
  - не используем узконаправленные признаки

## :red_square: Сортировка

### Сортировка с выбором

- Сортировка с выбором - алгоритм:
  1. Находим номер минимального значения в текущем списке
  2. производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
  3. теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы
- Сортировка с выбором имеет время выполнения в худшем, среднем и лучшем случае О(n^2), предполагая что сравнения делаются за постоянное время.

### Быстрая сортировка

- Быстрая сортировка часто применяется в реальных программах. 
- Быстрая сортировка основана на стратегии «разделяй и властвуй» и методе доказательства по индукции.  
- Алгоритм быстрой сортировки работает так: 
  1. Сначала в массиве выбирается элемент, который называется опорным.
  2. Разделить массив на два подмассива: элементы, меньшие опорного (слева), и элементы, большие опорного (справа). Эти два подмассива не отсортированы — они просто выделены из исходного массива.
  3. Рекурсивно применить быструю сортировку к двум подмассивам.
- Скорость алгоритма быстрой сортировки зависит от выбора опорного элемента. 
  - В худшем случае быстрая сортировка работает за время O(n^2).
  - В среднем быстрая сортировка выполняется за время O(n log n). 
  - Лучший случай является средним случаем. Если всегда выбирать опорным элементом случайный элемент в массиве, быстрая сортировка в среднем завершится за время O(n log n). 
- У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то что оба алгоритма характеризуются временем O(n log n), быстрая сортировка работает быстрее. 

### Алгоритм сортировки слиянием

- Алгоритм сортировки слиянием — работает за время 0(п log n).
