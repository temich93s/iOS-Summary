# Алгоритмы

## :red_square: Общее

### Общее

- **Алгоритм** - набор инструкций для выполнения некоторой задачи.
- **Псевдокод** – представляет собой высокоуровневое описание решаемой задачи. Он записывается в форме, похожей на программный код, но в большей степени напоминает естественный язык.
- **Стек вызовов** - когда вы вызываете функцию из другой функции, вызывающая функция приостанавливается в частично завершенном состоянии. Все значения переменных этой функции остаются в памяти. 
  - Каждый вызов создает собственную копию переменной х. Обратиться к переменной х, принадлежащей другой функции, невозможно.
  - Если стек вызовов станет очень большим, oн займет слишком много памяти.
- **Виды доступа** - всего существуют два вида доступа: произвольный (у массивов) и последовательный (у связанных списков).
  - Связанные списки - хорошо подходят для вставки/удаления. Так как надо поменять всего 1 указатель у предыдущего элемента, а у массива надо сдвигать все элементы.
  - Массивы - хорошо подходят для произвольного доступа к элементам.
 
### О-большое

- Всегда должны выбирать самый эффективный алгоритм по времени и/или по памяти.
- О-большое описывает скорость работы алгоритма.
- О-большое определяет время выполнения в худшем случае
- Скорость алгоритмов измеряется не в секундах, а в темпе роста количества операций. 
- Формула описывает, насколько быстро возрастает время выполнения алгоритма с увеличением размера входных данных.
-  В «О-большом» константы игнорируются и игнорируются числа, задействованные в операциях сложения, вычитания, умножения или деления. Ни одно из следующих значений не является правильной записью «О-большое»: О(n + 26), О(n - 26), О(n * 26), О(n / 26). Все они эквивалентны 0(n)
- Время 0(1) называется постоянным. 

### Рекурсия

- Рекурсией называется вызов функцией самой себя. 
- Каждая рекурсивная функция состоит из двух частей: базового случая и рекурсивного случая. 
  - В рекурсивном случае функция вызывает сама себя. 
  - В базовом случае функция себя не вызывает, чтобы предотвратить зацикливание.
- Когда вы пишете рекурсивную функцию, в которой задействован массив, базовым случаем часто оказывается пустой массив или массив из одного элемента.
- В языках функционального программирования циклов нет, поэтому для написания подобных функций приходится применять рекурсию. 

```Swift
import Foundation

func countDown(i : Int) {
    print(i)
    // Базовый случай
    if i <= 0 {
        return
    } else {
        // Рекурсивный случай
        countDown(i: i-1)
    }
}
countDown(i: 5)
```

```Swift
import Foundation

// Сумма с помощью рекурсии
func sum(list : [Int]) -> Int {
    if list.count == 0 {
        return 0
    }
    var tempArray = list
    tempArray.remove(at: 0)
    return list[0] + sum(list: tempArray)
}
print(sum(list: [1, 2, 3, 4])) // => 10

// Количество элементов с помощью рекурсии
func count(list : [Int]) -> Int {
    if list.count == 0 {
        return 0
    }
    var tempArray = list
    tempArray.remove(at: 0)
    return 1 + count(list: tempArray)
}
print(count(list: [1, 2, 3, 4])) // => 4

// максимальное число в массиве с помощью рекурсии
func max(list : [Int]) -> Int {
    if list.count == 2 {
        return (list[0] > list[1]) ? list[0] : list[1]
    } else if list.count < 2 {
        return list.first ?? 0
    }
    var tempArray = list
    tempArray.remove(at: 0)
    let subMax = max(list: tempArray)
    return (list[0] > subMax) ? list[0] : subMax
}
print(max(list: [1, 5, 10, 25, 16, 1])) // => 25
```

### NP-полные задачи

- NP-полные задачи - задчи в которых приходится перебирать все возможные решения что бы найти минимальное или максимальное значение (например задача о коммивояжере или задача о покрытии множества (радиостанции)
- NP-полные задачи - решаются через приближенный алгоритм
- Не существует простого способа определить, является ли задача, с которой вы работаете, NР-полной, несколько характерных признаков NP-полные задач:
  - ваш алгоритм быстро работает при малом количестве элементов, но сильно замедляется при увеличении их числа;
  - формулировка "все комбинации х" часто указывает на NР-полноту за­ дачи;
  - вам приходится вычислять все возможные варианты Х, потому что за­ дачу невозможно разбить на меньшие подзадачи? Такая задача может оказаться NР-полной;
  - если в задаче встречается некоторая последовательность (например, последовательность городов, как в задаче о коммивояжере) и задача не имеет простого решения, она может оказаться NР-полной;
  - если в задаче встречается некоторое множество (например, множество радиостанций) и задача не имеет простого решения, она может оказаться NР-полной;
  - можно ли переформулировать задачу в условиях задачи покрытия множества или задачи о коммивояжере? В таком случае ваша задача определенно является NР-полной.

### Метод доказательства по индукции. 

- Каждое индуктивное доказательство состоит из двух частей: базы (базового случая) и индукционного перехода.
- Работоспособность алгоритма быстрой сортировки: 
  - базовый случай — массивов с размером 0 и 1 — их сортировать не нужно. 
  - индукционный переход - если быстрая сортировка работает для массива из 1 элемента, то она будет работать для массива из 2 элементов. А если она работает для массивов из 2 элементов, то она будет работать для массивов из 3 элементов и т. д.

### Разделяй и властвуй

- Решение задачи методом «разделяй и властвуй» состоит из двух шагов:
  1.  Сначала определяется базовый случай. Это должен быть простейший случай из всех возможных.
  2.  Задача делится или сокращается до тех пор, пока не будет сведена к базовому случаю.

### Хеш-функция

- Хеш-функция, или функция свёртки — функция, осуществляющая преобразование массива входных данных произвольной длины в выходную битовую строку установленной длины, выполняемое определённым алгоритмом. 
- Хеш-функция должна соответствовать следующим требованиям:
  - Она должна быть последовательной. Передавая одно и то же значение получаем один и тот же результат.
  - Разным переданным значениям должны соответствовать разные результаты. 

## :red_square: Структуры данных

### Массивы
- Массив – хранит все элементы в памяти рядом, если что-то надо добавить, и соседняя память занята, то ищется новое свободное место в памяти для всего массива с новым элементом.
- Работая с массивом, вы заранее знаете адрес каждого его элемента. 
- Все массивы начинаются с 0
- Позиция элемента в массиве называется его индексом.
- Все элементы массива должны быть однотипными (только целые числа, только вещественные числа и т. д.).

### Связанные списки
- При использовании связанного списка элементы могут размещаться где угодно в памяти.
- В каждом элементе хранится адрес следующего элемента списка. Таким образом, набор - произвольных адресов памяти объединяется в цепочку.
- Обратиться к конкретному элементу списка напрямую нельзя. Мы не знаем заранее адрес каждого элемента. Данные у списков считываются последовательно.


### Стек

- Стек – абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO («последним пришёл — первым вышел»).
- Стек поддерживает всего два действия: занесение (вставка) и извлечение (выведение из списка и чтение

### Очереди

- Вы не можете обращаться к произвольным элементам очереди (как и у стека)
- Поддерживают всего две операции: постановка в очередь и извлечение из очереди
- Очередь относится к категории структур данных FIFO: First In, First Out («первым вошел, первым вышел»).

```Swift
// Очередь
public struct Deque<T> {
	// массив в котором элементы хранятся по правилу очереди
    private var array = [T]()
    
    // Пустая ли очередь
    public var isEmpty: Bool {
        return array.isEmpty
    }
    
    // кол-во элементов в очереди
    public var count: Int {
        return array.count
    }
    
    // добавление элемента в очередь
    public mutating func enqueue(_ element: T) {
        array.append(element)
    }
    
    // вставка элемента в очередь первым
    public mutating func enqueueFront(_ element: T) {
        array.insert(element, at: 0)
    }
    
    // удаление и возврат элемента из очереди (первого)
    public mutating func dequeue() -> T? {
        if isEmpty {
            return nil
        } else {
            return array.removeFirst()
        }
    }
    
    // удаление и возврат последнего элемента из очереди
    public mutating func dequeueBack() -> T? {
        if isEmpty {
            return nil
        } else {
            return array.removeLast()
        }
    }
    
    // получение первого элемента в очереди
    public func peekFront() -> T? {
        return array.first
    }
    
    // получение последнего элемента из очереди
    public func peekBack() -> T? {
        return array.last
    }
}
```

### Хеш-таблица

- Хеш-таблицы (словари) – связанные воедино хеш-функция и массив. Они определяют место хранения элементов при помощи хеш-функций.
- Хеш-таблица состоит из ключей и значений.
- В среднем хеш-таблицы выполняют любые операции за время 0(1).
- Хеш-таблицы хорошо подходят для решения следующих задач:
  - моделирование отношений между объектами;
  - устранение дубликатов;
  - кэширование/запоминание данных вместо выполнения работы на сервере.

```Swift
import Foundation

var book = [String: Double]()
book["apple"] = 0.67
```

#### Коллизии

- Коллизии - двум ключам назначается один элемент массива
- Существует много разных стратегий обработки коллизий. Простейшая из них выглядит так: если несколько ключей отображаются на один элемент, в этом элементе создается связанный список.
- Из этого примера следуют два важных урока:
  - хеш-функция должна распределять ключи равномерно по всему хешу;
  - если связанные списки становятся слишком длинными, работа с хеш-таблицей сильно замедляется.
- Для предотвращения коллизий необходимо:
  - низкий коэффициент заполнения;
  - хорошая хеш-функция.

#### Коэффициент заполнения

- Коэффициент заполнения = кол-во эл-тов в хеш-таблице / общее кол-во эл-тов
- С меньшим коэффициентом заполнения число коллизий уменьшается, и ваша таблица начинает работать более эффективно. 
- Хорошее приближенное правило: изменяйте размер хеш-таблицы, когда коэффициент заполнения превышает 0,7. 
  - Хорошая Хэш-функция должная обеспечивать равномерное распределение значений в массиве.
  - Плохая хеш-функция создает скопления и порождает множество коллизий.

### Графы

- Каждый граф состоит из узлов и ребер.
- Узел может быть напрямую соединен с несколькими другими узлами. Эти узлы называются соседями.
- Граф можно реализовать через хеш-таблицу
- В ненаправленном графе стрелок нет, и каждый из узлов является соседом по отношению друг к другу.
- Вес – число связанное с ребром графа
- Граф с весами называется взвешенным графом. Граф без весов называется невзвешенным графом.
- Для вычисления кратчайшего пути в невзвешенном графе используется поиск в ширину. 
- Кратчайшие пути во взвешенном графе вычисляются по алгоритму Дейкстры.
- В графах также могут присутствовать циклы: Само понятие ненаправленного графа означает, что каждый из двух узлов фактически ведет к другому узлу

### Множества

- множества похожи на списки, но множества не содержат дубликатов;
- с множествами можно выполнять различные интересные операции - вычислять их объединение, пересечение и разность.
- Объединение множеств означает слияние элементов обоих множеств. 
- Под операцией пересечения множеств понимается поиск элементов, входящих в оба множества (в данном случае - только помидор).
- Под разностью множеств понимается исключение из одного множества элементов, присутствующих в другом множестве.

## :red_square: Задачи

### Задача о коммивояжере 

- ЗАДАЧА: 
  - Коммивояжер хочет побывать в каждом из городов так, чтобы при этом проехать минимальное общее расстояние. 
- РЕШЕНИЕ (Разделяй и властвуй): 
  - Одно из возможных решений: нужно перебрать все возможные комбинации порядка объезда городов. Время выполнения составит 0(n!). Это одна из знаменитых нерешенных задач в области теории вычислений. Для нее не существует известного быстрого алгоритма, и ученые считают, что найти более эффективный алгоритм для этой задачи в принципе невозможно.

### Задача о покрытии множества 

- ЗАДАЧА: 
  - Надо выбрать оптимальное количество радиостанций. 
- РЕШЕНИЕ (Приближенный (жадный) алгоритм): 
  1. Выбратьстанцию,покрывающуюнаибольшееколичествоштатов,еще не входящих в покрытие. Если станция будет покрывать некоторые штаты, уже входящие в покрытие, это нормально.
  2. Повторять, пока остаются штаты, не входящие в покрытие.

### Задача про деление земли на равные квадраты

- ЗАДАЧА: 
  - Нужно разбить участок земли на равные квадраты.
- РЕШЕНИЕ (Алгоритм евклида - рекурсия):
  - Разбиваем участок земли на максимально большие квадраты. Оставшийся участок земли разбиваем заново на новые максимально возможные квадраты и т.д. повторяем пока оставшиеся участок не разобьется на квадраты поровну. Как разобьется минимальный квадрат и есть тот кваддрат на который можно разбить участок

### Задача про манго

- ЗАДАЧА: 
  - Есть манго надо найти ближайшего покупателя манго.
- РЕШЕНИЕ (Поиск в ширину): 
  1. создаем очередь из ближайших друзей
  2. проверяем друга из очереди (первого в очереди, по правилу очереди) готов ли он купить манго, если нет, то добавляем ближайших друзей этого проверенного друга в очередь (они добавляются в конец, по правилу очереди)
  3. повторяем. Проверяем следующего друга в очереди

```Swift

// Проверка что персонаж продает манго
func persionIsSeller(name: String) -> Bool {
    return name.characters.last == "m"
}

// Оформляем граф в виде хеш таблицы
var graph = [String : [String]]()
graph["you"] = ["alice", "bob", "claire"]
graph["bob"] = ["anuj", "peggy"]
graph["alice"] = ["peggy"]
graph["claire"] = ["thom", "jonny"]
graph["anuj"] = []
graph["peggy"] = []
graph["thom"] = []
graph["jonny"] = []

// функция поиска продавца
func search(name: String) -> Bool {
    // создаем очередь
    var searchQueue = Deque<String>()
    // добавляем персонажей в очередь
    for string in graph[name]! {
        searchQueue.enqueue(string)
    }
    // переменная отслеживает персонажей что уже были проверены
    var searched = [String]()
    // проверяем пока очередь не опустеет
    while !searchQueue.isEmpty {
        // получаем первого персонажа и удаляем его из очереди
        let person = searchQueue.dequeue()
        // проверяем что мы этого персонажа еще не проверяли
        if !searched.contains(person!) {
            // проверяем продает ли манго
            if persionIsSeller(name: person!) {
                print("\(person!) is a mango seller!")
                return true
            } else {
		// если не продает то добавляем его друзей в очередь
                for string in graph[person!]! {
                    searchQueue.enqueue(string)
                }
                // добавляем персонажа в список проверенных
                searched.append(person!)
            }
        }
    }
    return false
}

// Запускаем функцию поиска и выводит результат поиска
if search(name: "you") == false {
    print("Mango seller Not Found!")
} // => thom is a mango seller!
```

### Задача про обмен

- ЗАДАЧА: 
  - Максимально выгодно обменять предметы, где есть доплата при обмене. 
- РЕШЕНИЕ: Алгоритм Дейкстры
  - Узлы графа — это предметы, на которые может поменяться Рама. Веса ребер представляют сумму доплаты за обмен. 
  - Для реализации этого примера понадобятся три хеш-таблицы (граф, стоимости, родители).
  - Хеш-таблицы стоимостей и родителей будут обновляться по ходу работы алгоритма.
  - Стоимость узла определяет, сколько времени потребуется для перехода к этому узлу от начального узла.
  - так же нужен массив для отслеживания всех уже обработанных узлов, так как один узел не должен обрабатываться многократно.
  - Алгоритм:
    - Пока остаются необработанные узлы: 
    - взять узел ближайший к началу, 
    - обновить стоимости для его соседей
    - если стоимости каких-либо соседей были обновлены, обновить и родителей
    - пометит узел как обработанный и вернуться к началу алгоритма

### Задача про воришку и рюкзак

- ЗАДАЧА: 
  - Нужно положить в рюкзак ограниченного веса максимально дорогие вещи
- РЕШЕНИЕ: Динамическое программирование
  - составляем таблицу, где строка это предметы, а столбцы это от 0 до веса рюкзака, где кратность это вес минимального предмета
  - на каждом шаге заполняем таблицу, указывая можно ли добавить текущий предмет в рюкзак, или заменить предмет, если текущий предмет больше стоит текущей сумарной стоимости

### Задача про апельсины и грейпфруты

- ЗАДАЧА: 
  - Нужно определить по признакам фрукт относится к апельсинам или к грейпфруту
- РЕШЕНИЕ: Алгоритм к ближайших соседей
  - Размер и цвет - признаки, по которым ведется сравнение.
  - Для вычисления расстояния между двумя точками применяется формула Пифагора, где () это признак

## :red_square: Поиск

### Простой поиск

- Простой поиск - при каждой догадке исключается только одно число. Например, последовательное угадываение чисел.

### Бинарный поиск

- Бинарный поиск — на каждом шаге множество объектов делится на две части и в работе остаётся та часть множества, где находится искомый объект. 
- Бинарный поиск работает только с отсортированным списком элементов.

```Swift
import Foundation

// Бинарный поиск
func binarySearch <T: Comparable>(_ list: [T], item: T) -> Int? {
    // Устанавливаем верхнюю и нижнюю границу
    var low = 0
    var high = list.count - 1
    // Осуществляем поиск до тех пор пока не останется 1 элемент
    while low <= high {
        // Определяем средний элемент
        let mid = (low + high) / 2
        let guess = list[mid]
        // Проверяем нашли ли нужный элемент
        if guess == item {
            return mid
        }
        // Убираем половину списка в зависимости в какой половине хранится элемент
        if guess > item {
            high = mid - 1
        } else {
            low = mid + 1
        }
    } 
    return nil
}

let myList = [1, 3, 5, 7, 9]
print(binarySearch(myList, item: 3) ?? "Not Found") // => 1
print(binarySearch(myList, item: -1) ?? "Not Found") // => Not Found
```

### Поиск в ширину

- Поиск в ширину позволяет найти минимальное кол-во узлов между двумя объектами.
- Поиск в ширину работает с графами. Он помогает ответить на вопросы двух типов:
  - тип 1: существует ли путь от узла А к узлу В?
  - тип 2: как выглядит кратчайший путь от узла А к узлу В?
- Чтобы найти кратчайший путь, нужно выполнить два шага:
  1. Смоделировать задачу в виде графа.
  2. Решить задачу методом поиска в ширину.
- Поиск в ширину выполняется за время О(количество узлов + количество ребер), что обычно записывается в форме О(V+E) (У — количество узлов, Е — количество ребер). 

### Алгоритм дейкстры

- Алгоритм Дейкстры используется для поиска пути от начальной точки к конечной за кратчайшее возможное время.
- Алгоритм Дейкстры состоит из четырех шагов:
  1. Найти узел с наименьшей стоимостью (то есть узел, до которого можно добраться за минимальное время).
  2. Проверить, существует ли более дешевый путь к соседям этого узла, и если существует, обновить их стоимости.
  3. Повторять, пока это не будет сделано для всех узлов графа.
  4. Вычислить итоговый путь.
- Алгоритм Дейкстры работает только с направленными ациклическими графами, которые нередко обозначаются сокращением DAG (Directed Acyclic Graph).
- Алгоритм Дейкстры не может использоваться при наличии ребер, имеющих отрицательный вес. Такие ребра нарушают работу алгоритма. Если вы хотите найти кратчайший путь в графе, содержащем ребра с отрицательным весом, для этого существует специальный алгоритм, называемый алгоритмом Беллмапа- Форда.

```Swift
import Foundation

// Создаем граф в виде хеш-таблицы
var graph =  [String : [String: Double]] ()
graph["start"] = [String: Double]()
graph["start"]?["a"] = 6
graph["start"]?["b"] = 2

graph["a"] = [String: Double]()
graph["a"]?["fin"] = 1

graph["b"] = [String: Double]()
graph["b"]?["a"] = 3
graph["b"]?["fin"] = 5

graph["fin"] = [String: Double]()

// Создаем таблицу стоимости, которую будем обновлять
let infinity = Double.infinity
var costs = [String: Double]()
costs["a"] = 6
costs["b"] = 2
costs["fin"] = infinity

// Создаем таблицу родителей
var parents = [String: String]()
parents["a"] = "start"
parents["b"] = "start"
parents["fin"] = nil

// массив уже отслеженных узлов
var processed = [String]()

// функция определения ближайшего узла с наименьшей стоимостью
func findLowestCostNode(costs: [String: Double]) -> [String: Double] {
    // переменная равная бесконечности
    var lowestCost = Double.infinity
    // создаем перменную, которая будет узлом с наименьшей стоимостью
    var lowestCostNode = [String: Double]()
    // Проходим по всему массиву переданных узлов
    for node in costs {
        // получаем стоимость текущего узла
        let cost = node.value
        // Если это самая низкая стоимость на данный момент и если этот узел еще не был обработан
        if (cost < lowestCost) && !processed.contains(node.key) {
            // устанавливаем новую наименьшую стоимость узла
            lowestCost = cost
            // устанавливаем текущий узел как узел с наименьшей стоимостью на данный момент
            lowestCostNode = [node.key: node.value]
        }
        
    }
    // возвращаем узел с наименьшей стоимостью из переданного массива узлов
    return lowestCostNode
}

// Находим начальный узел с наименьшей стоимостью, что бы начать с него
var node = findLowestCostNode(costs: costs)

// обрабатываем пока не кончатся узлы
while !node.isEmpty {
    // получаем имя текущего узла (он у нас с наименьшей стоимостью) (тут массив, но в нем только 1 элемент)
    var nodeFirstKey = node.first?.key
    // получаем стоимость текущего узла
    var cost = costs[nodeFirstKey!]
    // получаем список соседей текущего узла
    var neighbors = graph[nodeFirstKey!]
    // проходим по всем соседям текущего узла
    for n in (neighbors?.keys)! {
        // создаем новую стоимость равную стоимости от начала до текущего узла + от текущего узла до исследуемого соседв
        var newCost = cost! + (neighbors?[n])!
        // Если обходной путь дешевле текущей стоимости из таблицы стоимостей
        if costs[n]! > newCost {
            // обновляем значение исследуемого узла на стоимость обходного пути
            costs[n] = newCost
            // Текущий узел становится родительским узлом исследуемого узла
            parents[n] = nodeFirstKey
        }
    }
    // помечаем узел как отслеженным
    processed.append(nodeFirstKey!)
    // ищем следующий узел с наименьшей стоимостью
    node = findLowestCostNode(costs: costs)
}

print("Cost from the start to each node:")
print(costs) // -> ["b": 2.0, "fin": 6.0, "a": 5.0]
```

### Алгоритм динамическое программирование

- Алгоритм динамического программирования начинается с решения подзадач с постепенным переходом к решению полной задачи.
- Каждый алгоритм динамического программирования начинается с таблицы. 
- При каждой итерации сохраняется текущая оценка максимума.
- Алгоритм динамического программированияне предусматривает возможность взять половину предмета.
- Динамическое программирование работает только в том случае, если каждая подзадача автономна, то есть не зависит от других подзадач.
- Динамическое программирование применяется для оптимизации какой-либо характеристики при заданных ограничениях.
- В каждом решении из области динамического программирования строится таблица;
- Значения ячеек таблицы обычно соответствуют оптимизируемой характеристике.
- Каждая ячейка представляет подзадачу, поэтому вы должны подумать о том, как разбить задачу на подзадачи. Это поможет вам определиться с осями.
- Не существует единой формулы для вычисления решений методом динамического программирования.

```Swift
import Foundation

// создаем слава что будем проверять
var wordA = "fish"
var wordB = "hish"

// создаем матрицу с числами, состоящую из нулей где столбцы символы слова hish, а стори символы слова fish
var cell : [[Int]] = Array(repeating: Array(repeating: 0, count: wordA.characters.count), count: wordB.characters.count)

//получаем массив из символов из слов fish и hish
let wordAArray = wordA.characters.map { String($0) }
let wordBArray = wordB.characters.map { String($0) }

// заполняем матрицу числами обозначающими сколько символов в сумме у обоих слов совпало
for i in 0...wordA.characters.count-1 {
    for j in 0...wordB.characters.count-1 {
        // если символы совпали
        if wordAArray[i] == wordBArray[j] {
            // если это ячейка не из 1 столбца и не из 1 строки, то добавляем 1 к значению верхней левой ячейки
            if i > 0 && j > 0 {
                cell[i][j] = cell[i-1][j-1] + 1
            // если нулевая, то ставим 1
            } else {
                cell[i][j] =  1
            }
        // если символы не совпали
        } else {
            // если это ячейка не из 1 столбца и не из 1 строки, то ставим максимальное значение из ячейки сверху и ячейки слева
            if i > 0 && j > 0 {
                cell[i][j] = max(cell[i-1][j], cell[i][j-1])
            // если нулевая, то ставим 0
            } else {
               cell[i][j] = 0
            }
        }
    }
}
```

### Алгоритм к ближайших соседей

- У алгоритма k ближайших соседей есть два основных применения: классификация и регрессия:
  - классификация - распределение по категориям;
  - регресия - прогнозирование ответа (в числовом выражении).
- Классификация: Для вычисления расстояния между двумя точками применяется формула Пифагора.
- Классификация: На практике также часто применяется метрика близости косинусов. Метрика близости косинусов не измеряет расстояние между двумя векторами. Вместо этого она сравнивает углы двух векторов и в целом лучше подходит для подобных случаев.
- Регресия: беруться ближайшие соседи и берется их среднее значение по предполагаемой оценке
- "Извлечением признаков" называется преобразование элемента (например, фрукта или пользователя) в список чисел, которые могут использоваться для сравнения.
- Качественный выбор признаков — важная часть успешного алгоритма k ближайших соседей. Под правильным выбором признаков следует понимать:
  - признаки, напрямую связанны с тем что мы пытаемся определить
  - не используем узконаправленные признаки

### Приближенный (жадный) алгоритм

- Когда вычисление точного реше­ ния занимает слишком много времени, применяется приближенный алго­ ритм. Эффективность приближенного алгоритма оценивается по:
  - быстроте;
  - близости полученного решения к оптимальному.

```Swift
import Foundation

// Набор штатов которые нужно покрыть наименьшим количеством радиостанций
var statesNeeded : Set = ["mt", "wa", "or", "id", "nv", "ut", "ca", "az"]

// Набор радиостанций
var stations = [String: Set<String>]()
stations["kone"] = ["id", "nv", "ut"]
stations["ktwo"] = ["wa", "id", "mt"]
stations["kthree"] = ["or", "nv", "ca"]
stations["kfour"] = ["nv", "ut"]
stations["kfive"] = ["ca", "az"]

// Результат - набор радиостанций
var finalStations = Set<String>();

// Делаем пока еще остаются непокрытые штаты
while !statesNeeded.isEmpty {
    // переменная содержащая имя лучшей станцию с наибольшим покрытием
    var bestStation = String()
    // переменная указывающая какие штаты покрывает наша лучшая радиостанция
    var statesCovered = Set<String>()
    // проходим по всем адиостанциям
    for station in stations {
        // получаем набор с штатов, которые являются общими как для исследуемой стации, так и для набора штатов.
        var covered = statesNeeded.intersection(station.value)
        // Если исследуемая станция покрывает больше предыдущих
        if covered.count > statesCovered.count {
            // сохраняем имя этой станции
            bestStation = station.key
            // сохраняем пул штатов который она покрывает
            statesCovered = covered
        }
        // получаем набор непокрытых штатов
        statesNeeded = statesNeeded.subtracting(statesCovered)
        // избегаем добавления пустой станции в набор
        if !bestStation.isEmpty {
            finalStations.insert(bestStation)
        }
    }
}

print(finalStations) // -> ["kone", "kfive", "ktwo", "kthree"]
```

## :red_square: Сортировка

### Сортировка с выбором

- Сортировка с выбором - алгоритм:
  1. Находим номер минимального значения в текущем списке
  2. производим обмен этого значения со значением первой неотсортированной позиции (обмен не нужен, если минимальный элемент уже находится на данной позиции)
  3. теперь сортируем хвост списка, исключив из рассмотрения уже отсортированные элементы
- Сортировка с выбором имеет время выполнения в худшем, среднем и лучшем случае О(n^2), предполагая что сравнения делаются за постоянное время.

```Swift
import Foundation

// Функция поиска индекса по которому находится наименьший элемент в массиве
func findSmallestIndex <T: Comparable> (_ arr: [T]) -> Int {
    // Переменная что хранит наименьший элемент массива
    var smallest = arr[0]
    // Переменная хранящая индекс по которому находится наименьший элемент в массиве
    var smallestIndex = 0
	// Поиск наименьшего элемента (простым поимком)
    for i in 1..<arr.count {
        if arr[i] < smallest {
            smallest = arr[i]
            smallestIndex = i
        }
    }
    return smallestIndex
}

// Сортировка массива с помощью сортировки с выбором 
func selectionSort <T: Comparable> (arr: [T]) -> [T] {
    // Проверяем состоит ли массив из 1 элемента, так как его не нужно сортировать
    guard arr.count > 1 else { return arr }
	// Переменная хранящая отсортированный массив
    var newArr: [T] = []
    // Создадаем копию входного массива которую будем редактировать
    var mutableArr = arr
    for _ in 0..<mutableArr.count {
        // Находим индек наименьшего элемента, вставляем его в отсортированный массив и удаляем его из неотсортированного массива
        let smallestIndex = findSmallestIndex(mutableArr)
        newArr.append(mutableArr.remove(at: smallestIndex))
    }
    return newArr
}

print(selectionSort(arr: [5, 3, 6, 2, 10])) // => [2, 3, 5, 6, 10]
```

### Быстрая сортировка

- Быстрая сортировка часто применяется в реальных программах. 
- Быстрая сортировка основана на стратегии «разделяй и властвуй» и методе доказательства по индукции.  
- Алгоритм быстрой сортировки работает так: 
  1. Сначала в массиве выбирается элемент, который называется опорным.
  2. Разделить массив на два подмассива: элементы, меньшие опорного (слева), и элементы, большие опорного (справа). Эти два подмассива не отсортированы — они просто выделены из исходного массива.
  3. Рекурсивно применить быструю сортировку к двум подмассивам.
- Скорость алгоритма быстрой сортировки зависит от выбора опорного элемента. 
  - В худшем случае быстрая сортировка работает за время O(n^2).
  - В среднем быстрая сортировка выполняется за время O(n log n). 
  - Лучший случай является средним случаем. Если всегда выбирать опорным элементом случайный элемент в массиве, быстрая сортировка в среднем завершится за время O(n log n). 
- У быстрой сортировки константа меньше, чем у сортировки слиянием, поэтому, несмотря на то что оба алгоритма характеризуются временем O(n log n), быстрая сортировка работает быстрее. 

```Swift
import Foundation

// Быстрая сортировка
func quicksort <T : Comparable> (_ array : [T]) -> [T] {
    // Базовый случай, массив из 0 или 1 элемента уже отсортирован    
    if (array.count < 2) {
        return array
    // Рекурсивный случай
    } else {
        // Берем элемент
        let pivot = array[0]
        // Подмассив, где все элементы меньше выбранного элемента
        let less = array.filter { $0 < pivot }
        // Подмассив, где все элементы равны выбранному элементу
        let equal = array.filter { $0 == pivot }
        // Подмассив, где все элементы больше выбранного элемента
        let greater = array.filter { $0 > pivot }
        // Рекурсивно осуществляем сортировку подмассивов
        return quicksort(less) + equal + quicksort(greater)
    }
}

print(quicksort([1, 5, 10, 25, 16, 1])) // => [1, 1, 5, 10, 16, 25]
```

### Алгоритм сортировки слиянием

- Алгоритм сортировки слиянием — работает за время 0(п log n).
